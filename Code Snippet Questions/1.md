# Why Does This Code Output `NaN`?

```javascript
var x = 10;
function helper() {
    x++;
    console.log(x);
    var x = 20;
}

helper();
```

## ‚ùì **Why **NaN** ‚ùì**

The output is `NaN` because of **variable hoisting** in **JavaScript**.

---

## üîç **Step-by-Step Analysis:**

### 1. **Declaration Hoisting:**

When JavaScript parses this function, it **hoists** the variable declaration (`var x`) to the top of its scope but **without initialization**.

```javascript
var x;
var x = 10;
function helper() {
    var x; // Hoisted declaration, but not initialized
    x++; // x is undefined here, so undefined + 1 = NaN
    console.log(x); // Logs NaN
    x = 20; // Now x is assigned 20
}
```

### 2. **Inside the **``** function:**

- At the start of the function, `var x` is **hoisted** as **undefined**.
- `x++` is essentially doing:

    ```javascript
    x = undefined + 1; // Results in NaN
    ```

- The `console.log(x)` outputs **NaN**.

### 3. **Why **`NaN`**?**

- `undefined + 1` is **not a valid number**, resulting in **NaN** (**Not a Number**).

---

## ‚úÖ **How to Fix It:**

### 1. **Initialize Before Using:**

```javascript
var x = 10;
function helper() {
    var x = 20; // Initialize before using
    x++;
    console.log(x); // Outputs 21
}

helper();
```

### 2. **Use the Global **``** Variable:**

If you intended to **increment the global **`` instead of declaring a new one:

```javascript
var x = 10;
function helper() {
    console.log(++x); // Outputs 11
}

helper();
```

---

## üí° **Key Takeaway:**

- **Declarations** are **hoisted**, but **initializations** are **not**.
- Always **declare** and **initialize** variables **before using them**.

